.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH CONFIGSPEC 1 "perl 5.005, patch 53" "15/Jul/98" "User Contributed Perl Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Tk::ConfigSpecs \- Defining behaviour of \*(L'configure\*(R' for composite widgets.
.SH "SYNOPSIS"
.PP
.Vb 9
\&    sub Populate
\&    {
\&     my ($composite,$args) = @_;
\&     ...
\&     $composite->ConfigSpecs('-attribute' => [ where,dbName,dbClass,default ]);
\&     $composite->ConfigSpecs('-alias' => '-otherattribute');
\&     $composite->ConfigSpecs('DEFAULT' => [ where ]);
\&     ...
\&    }
.Ve
.Vb 1
\&    $composite->configure(-attribute => value);
.Ve
.SH "DESCRIPTION"
The aim is to make the composite widget configure method look as much like
a regular Tk widget's configure as possible.
(See the \fITk::options\fR manpage for a description of this behaviour.)
To enable this the attributes that the composite as a whole accepts
needs to be defined.
.Sh "Defining the ConfigSpecs for a class."
Typically a widget will have one or more calls like the following
.PP
.Vb 1
\&    $composite->ConfigSpecs(-attribute => [where,dbName,dbClass,default]);
.Ve
in its \fBPopulate\fR method. When \fBConfigSpecs\fR is called this way
(with arguments) the arguments are used to construct or augment/replace
a hash table for the widget. (More than one \fI\-option\fR=>\fIvalue\fR
pair can be specified to a single call.)
.PP
\fBdbName\fR, \fBdbClass\fR and default are only used by \fBConfigDefault\fR described
below, or to respond to \*(L'inquiry\*(R' configure commands.
.PP
It may be either one of the values below, or a list of such values
enclosed in \fB[]\fR.
.PP
The currently permitted values of \fBwhere\fR are:
.Ip "\fB'\s-1ADVERTISED\s0\*(T'\fR" 4
apply \fBconfigure\fR to \fIadvertised\fR subwidgets.
.Ip "\fB'\s-1DESCENDANTS\s0\*(T'\fR" 4
apply \fBconfigure\fR recursively to all descendants.
.Ip "\fB'\s-1CALLBACK\s0\*(T'\fR" 4
Setting the attribute does \f(CWTk::Callback->new($value)\fR before storing
in \f(CW$composite->{Configure}{-attribute}\fR. This is appropriate for
\f(CW-command => ...\fR attributes that are handled by the composite and not
forwarded to a subwidget. (E.g. \fBTk::Tiler\fR has \f(CW-yscrollcommand\fR to
allow it to have scrollbar attached.)
.Sp
This may be the first of several \*(L'validating\*(R' keywords (e.g. font, cursor,
anchor etc.) that core Tk makes special for C code.
.Ip "\fB'\s-1CHILDREN\s0\*(T'\fR" 4
apply \fBconfigure\fR to all children.  (Children are the immediate
descendants of a widget.)
.Ip "\fB'\s-1METHOD\s0\*(T'\fR" 4
Call \f(CW$cw->attribute(value)\fR
.Sp
This is the most general case. Simply have a method of the composite
class with the same name as the attribute.  The method may do any
validation and have whatever side-effects you like.  (It is probably
worth \*(L'queueing\*(R' using \fBafterIdle\fR for more complex side-effects.)
.Ip "\fB'\s-1PASSIVE\s0\*(T'\fR" 4
Simply store value in \f(CW$composite->{Configure}{-attribute}\fR.
.Sp
This form is also a useful placeholder for attributes which you
currently only handle at create time.
.Ip "\fB'\s-1SELF\s0\*(T'\fR" 4
Apply \fBconfigure\fR to the core widget (e.g. \fBFrame\fR) that is the basis of
the composite. (This is the default behaviour for most attributes which
makes a simple Frame behave the way you would expect.) Note that once
you have specified \fBConfigSpecs\fR for an attribute you must explicitly
include \f(CW'SELF'\fR in the list if you want the attribute to apply to the
composite itself (this avoids nasty infinite recursion problems).
.Ip "\fB$reference\fR (blessed)" 4
Call \fB$reference\fR\->\fIconfigure\fR\|(\-attribute => value)
.Sp
A common case is where \fB$reference\fR is a subwidget.
.Sp
$reference may also be result of
.Sp
.Vb 1
\&     Tk::Config->new(setmethod,getmethod,args,...);
.Ve
\fBTk::Config\fR class is used to implement all the above keyword types.  The
class has \f(CWconfigure\fR and \f(CWcget\fR methods so allows higher level code to
\fIalways\fR just call one of those methods on an \fIobject\fR of some kind.
.Ip "\fBhash reference\fR" 4
Defining:
.Sp
.Vb 6
\&        $cw->ConfigSpecs(
\&                ...
\&                -option => [ { -optionX=>$w1, -optionY=>[$w2, $w3] },
\&                                dbname dbclass default ],
\&                ...
\&                );
.Ve
So \f(CW$cw->configure(-option => value)\fR actually does
.Sp
.Vb 3
\&        $w1->configure(-optionX => value);
\&        $w2->configure(-optionY => value);
\&        $w3->configure(-optionY => value);
.Ve
.Ip "\fB'otherstring\*(T'\fR" 4
Call
.Sp
.Vb 1
\&    $composite->Subwidget('otherstring')->configure( -attribute => value );
.Ve
While this is here for backward compatibility with Tk-b5, it is probably
better just to use the subwidget reference directly.  The only
case for retaining this form is to allow an additional layer of
abstraction \- perhaps having a \*(L'current\*(R' subwidget \- this is unproven.
.Ip "\fBAliases\fR" 4
\f(CWConfigSpecs( -alias => '-otherattribute' )\fR is used to make \f(CW-alias\fR
equivalent to \f(CW-otherattribute\fR. For example the aliases
.Sp
.Vb 2
\&    -fg => '-foreground',
\&    -bg => '-background'
.Ve
are provided automatically (if not already specified).
.Sh "Default Values"
When the \fBPopulate\fR method returns \fBConfigDefault\fR is called.  This calls
.PP
.Vb 1
\&    $composite->ConfigSpecs;
.Ve
(with no arguments) to return a reference to a hash. Entries in the hash
take the form:
.PP
.Vb 1
\&    '-attribute' => [ where, dbName, dbClass, default ]
.Ve
\fBConfigDefault\fR ignores \*(L'where\*(R' completely (and also the \s-1DEFAULT\s0 entry) and
checks the \*(L'options\*(R' database on the widget's behalf, and if an entry is
present matching dbName/dbClass
.PP
.Vb 1
\&    -attribute => value
.Ve
is added to the list of options that \fBnew\fR will eventually apply to the
widget. Likewise if there is not a match and default is defined this
default value will be added.
.PP
Alias entries in the hash are used to convert user-specified values for the
alias into values for the real attribute.
.Sh "\fINew()\fR\-time Configure"
Once control returns to \fBnew\fR, the list of user-supplied options
augmented by those from \fBConfigDefault\fR are applied to the widget using the
\fBconfigure\fR method below.
.PP
Widgets are most flexible and most Tk-like if they handle the majority of
their attributes this way.
.Sh "Configuring composites"
Once the above have occurred calls of the form:
.PP
.Vb 1
\&    $composite->configure( -attribute => value );
.Ve
should behave like any other widget as far as end-user code is concerned.
\fBconfigure\fR will be handled by \fBTk::Derived::configure\fR as follows:
.PP
.Vb 1
\&    $composite->ConfigSpecs;
.Ve
is called (with no arguments) to return a reference to a hash \fB\-attribute\fR is
looked up in this hash, if \fB\-attribute\fR is not present in the hash then
\&\fB'\s-1DEFAULT\s0\*(R'\fR is looked for instead.  (Aliases are tried as well and cause
redirection to the aliased attribute).  The result should be a reference to a
list like:
.PP
.Vb 1
\&  [ where, dbName, dbClass, default ]
.Ve
at this stage only \fIwhere\fR is of interest, it maps to a list of object
references (maybe only one) foreach one
.PP
.Vb 1
\&   $object->configure( -attribute => value );
.Ve
is \fBeval\fRed.
.Sh "Inquiring attributes of composites"
.PP
.Vb 1
\&   $composite->cget( '-attribute' );
.Ve
This is handled by  \fBTk::Derived::cget\fR in a similar manner to configure. At
present if \fIwhere\fR is a list of more than one object it is ignored completely
and the \*(L"cached\*(R" value in
.PP
.Vb 1
\&   $composite->{Configure}{-attribute}.
.Ve
is returned.
.SH "CAVEATS"
It is the author's intention to port as many of the \*(L"Tix\*(R" composite widgets
as make sense. The mechanism described above may have to evolve in order to
make this possible, although now aliases are handled I think the above is
sufficient.
.SH "SEE ALSO"
Tk::composite,
Tk::options

.rn }` ''
.IX Title "CONFIGSPEC 1"
.IX Name "Tk::ConfigSpecs - Defining behaviour of 'configure' for composite widgets."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Subsection "Defining the ConfigSpecs for a class."

.IX Item "\fB'\s-1ADVERTISED\s0\*(T'\fR"

.IX Item "\fB'\s-1DESCENDANTS\s0\*(T'\fR"

.IX Item "\fB'\s-1CALLBACK\s0\*(T'\fR"

.IX Item "\fB'\s-1CHILDREN\s0\*(T'\fR"

.IX Item "\fB'\s-1METHOD\s0\*(T'\fR"

.IX Item "\fB'\s-1PASSIVE\s0\*(T'\fR"

.IX Item "\fB'\s-1SELF\s0\*(T'\fR"

.IX Item "\fB$reference\fR (blessed)"

.IX Item "\fBhash reference\fR"

.IX Item "\fB'otherstring\*(T'\fR"

.IX Item "\fBAliases\fR"

.IX Subsection "Default Values"

.IX Subsection "\fINew()\fR\-time Configure"

.IX Subsection "Configuring composites"

.IX Subsection "Inquiring attributes of composites"

.IX Header "CAVEATS"

.IX Header "SEE ALSO"

