.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PTK 1 "Tk402.003" "2/Aug/97" "perl/Tk Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
Tk2portableTk \- how to make your \fBTk\fR source portable to other
interpreted languages.
.SH "Author"
Ilya Zakharevich <ilya@math.ohio-state.edu>  has contributed most of 
this document. Many thanks.
.SH "DESCRIPTION"
\fBPortableTk\fR is an attempt to make \fBTk\fR useful from other
languages. Currently tk4.0 runs under Perl using this
approach. Below, \fILang\fR is the notation for an external language to
which \fBPortableTk\fR glues \fBTk\fR code.
.PP
The main problem with using the code developed for \fBTCL\fR with
different languages is the absence of data types: almost anything is
\f(CWchar*\fR. It makes automatic translation hopeless. However, if you
\f(CWtypedef\fR several new symbols to be \f(CWchar*\fR, you can still use your
code in \fBTCL\fR, \fIand\fR it will make the automatic translation
possible.
.PP
Another problem with the approach that \*(L"everything is a string\*(R" is
impossibility to have a result that says \*(L"NotApplicable\*(R" without
setting an error. Thus different \fBTk\fR command return different string
values that mean \*(L"error happened\*(R", like \f(CW""\fR, \f(CW" "\fR or
\f(CW"??"\fR. Other languages can be more flexible, so in \fBportableTk\fR you
should inform the compiler that what you want to return means \*(L"error\*(R"
(see the section on \fISetting variables\fR).
.PP
Currently \fBPortableTk\fR uses several different approachs
to simplify translation: several \fBTCL\fR functions that are especially
dangerous to use are undefined, so you can easily find places that
need to be updated to use Language-independent functions based on
compiler warnings.  Eventually a way to use these Language-independent
functions under proper \fBTCL\fR will be also provided.  The end of this 
document provides a starting point for such a project.
.SH "Structure of \fBpTk\fR, porting your code"
\fBpTk\fR, that is a port of \fBTk\fR, is very special with respect to porting
of other code to \fBportableTk\fR. The problem is that currently there is
very little hope to merge the modifications back into \fBTk\fR, so a
special strategy is needed to maintain this port. Do not use this
strategy to port your own code.
.PP
\fBpTk\fR is produced from \fBTk\fR via a two-step process: first, some
manual editing (the result is in the subdirectory \f(CWmTk\fR), and second,
automatic conversion by the \f(CWmunge\fR script (written in Perl). Thus the
subdirectory \f(CWpTk/mTk\fR contains code with minimal possible difference
from the virgin \fBTk\fR code, so it is easier to \fImerge\fR\|(1) the
differences between \fBTk\fR versions into modified code.
.PP
It looks like the strategy for a portable code should be exactly
opposite: starting from \fBTCL\fR\-based code, apply \f(CWmunge\fR, and then
hand-edit the resulting code. Probably it is also possible to target
your code to \fBportableTk\fR from scratch, since this will make it
possible to run it under a lot of \fILang\fRuages.
.PP
The only reason anyone would like to look into contents of \f(CWpTk/mTk\fR
directory is to find out which constructs are not supported by
\f(CWmunge\fR. On the other hand, \f(CWpTk\fR directory contains code that is
conformant to \fBportableTk\fR, so you can look there to find example code.
.PP
\f(CWmunge\fR is the script that converts most common \fBTk\fR constructs to
their \f(CWportableTk\fR equivalent. For your code to qualify, you should
follow \fBTk\fR conventions on indentation and names of variables, in
particular, the array of arguments for the \f(CW...CmdProc\fR should be
called \f(CWargv\fR.
.PP
For details on what \f(CWmunge\fR can do, see 
the section on \fITranslation of some TCL functions\fR. 
.SH "\fBPortableTk\fR API"
.Sh "Checking what you are running under"
\fBPortableTk\fR provides a symbol \f(CW????\fR. If this symbol is defined,
your source is compiled with it.
.Sh "New types of configuration options"
\fBPortableTk\fR defines several new types of configuration options:
.PP
.Vb 6
\& TK_CONFIG_CALLBACK
\& TK_CONFIG_LANGARG
\& TK_CONFIG_SCALARVAR
\& TK_CONFIG_HASHVAR
\& TK_CONFIG_ARRAYVAR
\& TK_CONFIG_IMAGE
.Ve
You should use them instead of \s-1TK_CONFIG_STRING\s0 whenever
appropriate. This allows your application to receive a direct
representation of the corresponding resource instead of the string
representation, if this is possible under given language.
.PP
???? It looks like \f(CWTK_CONFIG_IMAGE\fR and \f(CWTK_CONFIG_SCALARVAR\fR set
variables of type \f(CWchar*\fR.
.Sh "Language data"
The following data types are defined:
.Ip "\f(CWArg\fR" 15
is the main datatype of the language.  This is a type that your C
function gets pointers to for arguments when the corresponding \fILang\fR
function is called.  The corresponding config type is
\f(CWTK_CONFIG_LANGARG\fR.
.Sp
This is also a type that keeps information about contents of \fILang\fR
variable. 
.Ip "\f(CWVar\fR" 15
Is a substitute for a \f(CWchar *\fR that contains name of variable. In
\fILang\fR it is an object that contains reference to another \fILang\fR
variable.
.Ip "\f(CWLangResultSave\fR" 15
????
.Ip "\f(CWLangCallback\fR" 15
\f(CWLangCallback*\fR a substitute for a \f(CWchar *\fR that contains command to
call. The corresponding config type is \f(CWTK_CONFIG_CALLBACK\fR.
.Ip "\f(CWLangFreeProc\fR" 15
It is the type that the \f(CWLang_SplitList\fR sets. Before you call it,
declare 
.Sp
.Vb 5
\&    Args *args;
\&    LangFreeProc *freeProc = NULL;
\&    ...
\&    code = Lang_SplitList(interp, value, 
\&        &argc, &args, &freeProc);
.Ve
After you use the split values, call 
.Sp
.Vb 1
\&    if (args != NULL && freeProc) (*freeProc)(argc,args);
.Ve
It is not guaranteed that the \f(CWargs\fR can survive deletion of \f(CWvalue\fR.
.Sh "Conversion"
The following macros and functions are used for conversion between
strings and the additional types:
.PP
.Vb 3
\& LangCallback * LangMakeCallback(Arg)
\& Arg LangCallbackArg(LangCallback *)
\& char * LangString(Arg)
.Ve
After you use the result of \fILangCallbackArg()\fR, you should free it with
\f(CWfreeProc\fR \f(CWLANG_DYNAMIC\fR (it is not guaranteed that any change of
\f(CWArg\fR will not be reflected in <LangCallback>, so you cannot do
LangSet...() in between, and you should reset it to \f(CWNULL\fR if you
want to do any further assignments to this \f(CWArg\fR).
.PP
The following function returns the \f(CWArg\fR that is a reference to \f(CWVar\fR:
.PP
.Vb 1
\& Arg LangVarArg(Var)
.Ve
???? It is very anti-intuitive, I hope the name is changed.
.PP
.Vb 1
\& int LangCmpCallback(LangCallback *a,Arg b)
.Ve
(currently only a stub), and, at last,
.PP
.Vb 1
\& LangCallback * LangCopyCallback(LangCallback *)
.Ve
.Sh "Callbacks"
Above we have seen the new datatype \f(CWLangCallback\fR and the
corresponding \fIConfig option\fR  \f(CWTK_CONFIG_CALLBACK\fR. The following
functions are provided for manipulation of \f(CWLangCallback\fRs:
.PP
.Vb 3
\& void LangFreeCallback(LangCallback *)
\& int LangDoCallback(Tcl_Interp *,LangCallback *,
\&        int result,int argc, char *format,...)
.Ve
The argument \f(CWformat\fR of \f(CWLangDoCallback\fR should contain a string that is
suitable for \f(CWsprintf\fR with optional arguments of \f(CWLangDoCallback\fR.
\f(CWresult\fR should be false if result of callback is not needed.
.PP
.Vb 2
\& int LangMethodCall(Tcl_Interp *,Arg,char *method,
\&        int result,int argc,...)
.Ve
????
.PP
Conceptually, \f(CWLangCallback*\fR is a substitute for ubiquitous \f(CWchar *\fR
in \fB\s-1TCL\s0\fR. So you should use \f(CWLangFreeCallback\fR instead of \f(CWckfree\fR
or \f(CWfree\fR if appropriate.
.Sh "Setting variables"
.PP
.Vb 5
\& void LangFreeArg (Arg, Tcl_FreeProc *freeProc)
\& Arg  LangCopyArg (Arg);
\& void Tcl_AppendArg (Tcl_Interp *interp, Arg)
\& void LangSetString(Arg *, char *s)
\& void LangSetDefault(Arg *, char *s)
.Ve
These two are equivalent unless s is an empty string. In this case
\f(CWLangSetDefault\fR behaves like \f(CWLangSetString\fR with \f(CWs==NULL\fR, i.e.,
it sets the current value of the \fILang\fR variable to be false.
.PP
.Vb 2
\& void LangSetInt(Arg *,int)
\& void LangSetDouble(Arg *,double)
.Ve
The \fILang\fR functions separate uninitialized and initialized data
comparing data with \f(CWNULL\fR. So the declaration for an \f(CWArg\fR should
look like
.PP
.Vb 1
\& Arg arg = NULL;
.Ve
if you want to use this \f(CWarg\fR with the above functions. After you are
done, you should use \f(CWLangFreeArg\fR with \f(CWTCL_DYNAMIC\fR as \f(CWfreeProc\fR.
.Sh "Language functions"
Use
.Ip "\f(CWint  LangNull(Arg)\fR" 25
to check that an object is false;
.Ip "\f(CWint  LangStringMatch(char *string, Arg match)\fR" 25
????
.Ip "\f(CWvoid LangExit(int)\fR" 25
to make a proper shutdown;
.Ip "\f(CWint LangEval(Tcl_Interp *interp, char *cmd, int global)\fR" 25
to call \fILang\fR \f(CWeval\fR;
.Ip "\f(CWvoid Lang_SetErrorCode(Tcl_Interp *interp,char *code)\fR" 25
.Ip "\f(CWchar *Lang_GetErrorCode(Tcl_Interp *interp)\fR" 25
.Ip "\f(CWchar *Lang_GetErrorInfo(Tcl_Interp *interp)\fR" 25
.Ip "\f(CWvoid LangCloseHandler(Tcl_Interp *interp,Arg arg,FILE *f,Lang_FileCloseProc *proc)\fR" 25
currently stubs only;
.Ip "\f(CWint LangSaveVar(Tcl_Interp *,Arg arg,Var *varPtr,int type)\fR" 25
to save the structure \f(CWarg\fR into \fILang\fR variable \f(CW*varPtr\fR;
.Ip "\f(CWvoid LangFreeVar(Var var)\fR" 25
to free the result;
.Ip "\f(CWint LangEventCallback(Tcl_Interp *,LangCallback *,XEvent *,KeySym)\fR" 25
????
.Ip "\f(CWint LangEventHook(int flags)\fR" 25
.Ip "\f(CWvoid LangBadFile(int fd)\fR" 25
.Ip "\f(CWint LangCmpConfig(char *spec, char *arg, size_t length)\fR" 25
unsupported????;
.Ip "\f(CWvoid Tcl_AppendArg (Tcl_Interp *interp, Arg)\fR" 25
.PP
Another useful construction is
.PP
.Vb 1
\& Arg variable = LangFindVar(interp, Tk_Window tkwin, char *name);
.Ve
After using the above function, you should call
.PP
.Vb 1
\& LangFreeVar(Var variable);
.Ve
???? Note discrepancy in types!
.PP
If you want to find the value of a variable (of type \f(CWArg\fR) given the
variable name, use \f(CWTcl_GetVar(interp, varName, flags)\fR. If you are
interested in the string value of this variable, use
\f(CWLangString(Tcl_GetVar(...))\fR.
.PP
To get a \fBC\fR array of \f(CWArg\fR of length \f(CWn\fR, use 
.PP
.Vb 3
\&    Arg *args = LangAllocVec(n);
\&    ...
\&    LangFreeVec(n,args);
.Ve
You can set the values of the \f(CWArg\fRs using \f(CWLangSet...\fR functions,
and get string value using \f(CWLangString\fR.
.PP
If you want to merge an array of \f(CWArg\fRs into one \f(CWArg\fR (that will
be an array variable), use
.PP
.Vb 1
\&    result = Tcl_Merge(listLength, list);
.Ve
.Sh "Translation of some \s-1TCL\s0 functions"
We mark items that can be dealt with by \f(CWmunge\fR by \fIAutoconverted\fR.
.Ip "\f(CWTcl_AppendResult\fR " 20
does not take \f(CW(char*)NULL\fR, but \f(CWNULL\fR as delimiter. \fIAutoconverted\fR.
.Ip "\f(CWTcl_CreateCommand\fR, \f(CWTcl_DeleteCommand\fR " 20
\f(CWTk_CreateWidget\fR, \f(CWTk_DeleteWidget\fR, the second argument is the
window itself, not the pathname. \fIAutoconverted\fR.
.Ip "\f(CWsprintf(interp->result, "%d %d %d %d",...)\fR " 20
\f(CWTcl_IntResults(interp,4,0,...)\fR. \fIAutoconverted\fR.
.Ip "\f(CWinterp->result = "1";\fR" 20
\f(CWTcl_SetResult(interp,"1", TCL_STATIC)\fR. \fIAutoconverted\fR.
.Ip "Reading \f(CWinterp->result\fR " 20
\f(CWTcl_GetResult(interp)\fR. \fIAutoconverted\fR.
.Ip "\f(CWinterp->result = Tk_PathName(textPtr->tkwin);\fR" 20
\f(CW\fITk_WidgetResult\fR\|(interp,textPtr->tkwin)\fR. \fIAutoconverted\fR.
.Ip "Sequence \f(CWTcl_PrintDouble, Tcl_PrintDouble, ..., Tcl_AppendResult\fR " 20
Use a single command 
.Sp
.Vb 2
\& void Tcl_DoubleResults(Tcl_Interp *interp, int append,
\&        int argc,...);
.Ve
\f(CWappend\fR governs whether it is required to clear the result first.
.Sp
A similar command for \f(CWint\fR arguments is \f(CWTcl_IntResults\fR.
.Ip "\f(CWTcl_SplitList\fR " 20
Use \f(CWLang_SplitList\fR (see the description above).
.SH "Translation back to TCL"
To use your \fBportableTk\fR program with \fBTCL\fR, put
.PP
.Vb 1
\& #include "ptcl.h"
.Ve
\fIbefore\fR inclusion of \f(CWtk.h\fR, and link the resulting code with
\f(CWptclGlue.c\fR.
.PP
These files currently implement the following:
.Ip "Additional config types:" 5
.Sp
.Vb 6
\& TK_CONFIG_CALLBACK
\& TK_CONFIG_LANGARG
\& TK_CONFIG_SCALARVAR
\& TK_CONFIG_HASHVAR
\& TK_CONFIG_ARRAYVAR
\& TK_CONFIG_IMAGE
.Ve
.Ip "Types:" 5
.Sp
.Vb 1
\& Var, Arg, LangCallback, LangFreeProc.
.Ve
.Ip "Functions and macros:" 5
.Sp
.Vb 6
\& Lang_SplitList, LangString, LangSetString, LangSetDefault,
\& LangSetInt, LangSetDouble Tcl_ArgResult, LangCallbackArg,
\& LangSaveVar, LangFreeVar,
\& LangFreeSplitProc, LangFreeArg, Tcl_DoubleResults, Tcl_IntResults,
\& LangDoCallback, Tk_WidgetResult, Tcl_CreateCommand,
\& Tcl_DeleteCommand, Tcl_GetResult.
.Ve
.PP
Current implementation contains enough to make it possible to compile
\f(CWmTk/tkText*.[ch]\fR with the virgin \fBTk\fR.
.Sh "New types of events ????"
PortableTk defines following new types of events:
.PP
.Vb 7
\& TK_EVENTTYPE_NONE
\& TK_EVENTTYPE_STRING
\& TK_EVENTTYPE_NUMBER
\& TK_EVENTTYPE_WINDOW
\& TK_EVENTTYPE_ATOM
\& TK_EVENTTYPE_DISPLAY
\& TK_EVENTTYPE_DATA
.Ve
and a function
.PP
.Vb 4
\& char * Tk_EventInfo(int letter, 
\&            Tk_Window tkwin, XEvent *eventPtr, 
\&            KeySym keySym, int *numPtr, int *isNum, int *type, 
\&            int num_size, char *numStorage)
.Ve
.SH "Checking for trouble"
If you start with working TCL code, you can start convertion using
the above hints. Good indication that you are doing is OK is absence
of \f(CWsprintf\fR and \f(CWsscanf\fR in your code (at least in the part that is
working with interpreter).
.SH "Additional API"
What is described here is not included into base \fBportableTk\fR
distribution. Currently it is coded in \fBTCL\fR and as Perl macros (core
is coded as functions, so theoretically you can use the same object
files with different interpreted languages).
.Sh "\f(CWListFactory\fR"
Dynamic arrays in \fB\s-1TCL\s0\fR are used for two different purposes: to
construct strings, and to construct lists. These two usages will have
separate interfaces in other languages (since list is a different type
from a string), so you should use a different interface in your code.
.PP
The type for construction of dynamic lists is \f(CWListFactory\fR. The \s-1API\s0
below is a counterpart of the \s-1API\s0 for construction of dynamic lists
in \fB\s-1TCL\s0\fR:
.PP
.Vb 9
\& void ListFactoryInit(ListFactory *)
\& void ListFactoryFinish(ListFactory *)
\& void ListFactoryFree(ListFactory *)
\& Arg * ListFactoryArg(ListFactory *)
\& void ListFactoryAppend(ListFactory *, Arg *arg)
\& void ListFactoryAppendCopy(ListFactory *, Arg *arg)
\& ListFactory * ListFactoryNewLevel(ListFactory *)
\& ListFactory * ListFactoryEndLevel(ListFactory *)
\& void ListFactoryResult(Tcl_Interp *, ListFactory *)
.Ve
The difference is that a call to \f(CWListFactoryFinish\fR should precede the
actual usage of the value of \f(CWListFactory\fR, and there are two
different ways to append an \f(CWArg\fR to a \f(CWListFactory\fR:
\fIListFactoryAppendCopy()\fR guarantees that the value of \f(CWarg\fR is copied
to the list, but \fIListFactoryAppend()\fR may append to the list a
reference to the current value of \f(CWarg\fR. If you are not going to change
the value of \f(CWarg\fR after appending, the call to ListFactoryAppend may
be quicker.
.PP
As in \fB\s-1TCL\s0\fR, the call to \fIListFactoryFree()\fR does not free the
\f(CWListFactory\fR, only the objects it references.
.PP
The functions \fIListFactoryNewLevel()\fR and \fIListFactoryEndLevel()\fR return a
pointer to a \f(CWListFactory\fR to fill. The argument of
\fIListFactoryEndLevel()\fR cannot be used after a call to this function.
.Sh "DStrings "
Production of strings are still supported in \fBportableTk\fR.
.Sh "Accessing \f(CWArg\fRs"
The following functions for getting a value of an \f(CWArg\fR \fImay\fR be
provided:
.PP
.Vb 4
\& double LangDouble(Arg)
\& int LangInt(Arg)
\& long LangLong(Arg)
\& int LangIsList(Arg arg) 
.Ve
The function \fILangIsList()\fR is supported only partially under \fB\s-1TCL\s0\fR,
since there is no data types. It checks whether there is a space
inside the string \f(CWarg\fR.
.Sh "Assigning numbers to \f(CWArg\fRs"
While \fILangSetDouble()\fR and \fILangSetInt()\fR are supported ways to assign
numbers to assign an integer value to a variable, for the sake of
efficiency under \fB\s-1TCL\s0\fR it is supposed that the destination of these
commands was massaged before the call so it contains a long enough
string to \fIsprintf()\fR the numbers inside it. If you are going to
immediately use the resulting \f(CWArg\fR, the best way to do this is to
declare a buffer in the beginning of a block by
.PP
.Vb 1
\&   dArgBuffer;
.Ve
and assign this buffer to the \f(CWArg\fR by
.PP
.Vb 1
\&   void LangSetDefaultBuffer(Arg *)
.Ve
You can also create the \fIbuffer\fR\|(s) manually and assign them using
.PP
.Vb 1
\&   void LangSetBuffer(Arg *, char *)
.Ve
This is the only choice if you need to assign numeric values to
several \f(CWArg\fRs simultaneously. The advantage of the first approach is
that the above declarations can be made \f(CWnop\fRs in different languages.
.PP
Note that if you apply \f(CWLangSetDefaultBuffer\fR to an \f(CWArg\fR that
contains some value, you can create a leak if you do not free that
\f(CWArg\fR first. This is a non-problem in real languages, but can be a
trouble in \f(CWTCL\fR, unless you use only the above \s-1API\s0.
.Sh "Creating new \f(CWArg\fRs"
The \s-1API\s0 for creating a new \f(CWArg\fR is
.PP
.Vb 1
\& void LangNewArg(Arg *, LangFreeProc *)
.Ve
The \s-1API\s0 for creating a new \f(CWArg\fR is absent. Just initialize \f(CWArg\fR to
be \f(CWNULL\fR, and apply one of \f(CWLangSet...\fR methods.
.PP
After you use this \f(CWArg\fR, it should be freed thusly:
.PP
\f(CWLangFreeArg(arg, freeProc)\fR.
.Sh "Evaluating a list"
Use
.PP
.Vb 1
\& int LangArgEval(Tcl_Interp *, Arg arg)
.Ve
Here \f(CWarg\fR should be a list to evaluate, in particular, the first
element should be a \f(CWLangCallback\fR massaged to be an \f(CWArg\fR. The
arguments can be send to the subroutine by reference or by value in
different languages.
.Sh "Getting result as \f(CWArg\fR"
Use \f(CWTcl_ArgResult\fR. It is not guaranteed that result survives this
operation, so the \f(CWArg\fR you get should be the only mean to access the
data from this moment on. After you use this \f(CWArg\fR, you should free
it with \f(CWfreeProc\fR \f(CWLANG_DYNAMIC\fR (you can do LangSet...() in between).

.rn }` ''
.IX Title "PTK 1"
.IX Name "Tk2portableTk - how to make your B<Tk> source portable to other
interpreted languages."

.IX Header "NAME"

.IX Header "Author"

.IX Header "DESCRIPTION"

.IX Header "Structure of \fBpTk\fR, porting your code"

.IX Header "\fBPortableTk\fR API"

.IX Subsection "Checking what you are running under"

.IX Subsection "New types of configuration options"

.IX Subsection "Language data"

.IX Item "\f(CWArg\fR"

.IX Item "\f(CWVar\fR"

.IX Item "\f(CWLangResultSave\fR"

.IX Item "\f(CWLangCallback\fR"

.IX Item "\f(CWLangFreeProc\fR"

.IX Subsection "Conversion"

.IX Subsection "Callbacks"

.IX Subsection "Setting variables"

.IX Subsection "Language functions"

.IX Item "\f(CWint  LangNull(Arg)\fR"

.IX Item "\f(CWint  LangStringMatch(char *string, Arg match)\fR"

.IX Item "\f(CWvoid LangExit(int)\fR"

.IX Item "\f(CWint LangEval(Tcl_Interp *interp, char *cmd, int global)\fR"

.IX Item "\f(CWvoid Lang_SetErrorCode(Tcl_Interp *interp,char *code)\fR"

.IX Item "\f(CWchar *Lang_GetErrorCode(Tcl_Interp *interp)\fR"

.IX Item "\f(CWchar *Lang_GetErrorInfo(Tcl_Interp *interp)\fR"

.IX Item "\f(CWvoid LangCloseHandler(Tcl_Interp *interp,Arg arg,FILE *f,Lang_FileCloseProc *proc)\fR"

.IX Item "\f(CWint LangSaveVar(Tcl_Interp *,Arg arg,Var *varPtr,int type)\fR"

.IX Item "\f(CWvoid LangFreeVar(Var var)\fR"

.IX Item "\f(CWint LangEventCallback(Tcl_Interp *,LangCallback *,XEvent *,KeySym)\fR"

.IX Item "\f(CWint LangEventHook(int flags)\fR"

.IX Item "\f(CWvoid LangBadFile(int fd)\fR"

.IX Item "\f(CWint LangCmpConfig(char *spec, char *arg, size_t length)\fR"

.IX Item "\f(CWvoid Tcl_AppendArg (Tcl_Interp *interp, Arg)\fR"

.IX Subsection "Translation of some \s-1TCL\s0 functions"

.IX Item "\f(CWTcl_AppendResult\fR "

.IX Item "\f(CWTcl_CreateCommand\fR, \f(CWTcl_DeleteCommand\fR "

.IX Item "\f(CWsprintf(interp->result, "%d %d %d %d",...)\fR "

.IX Item "\f(CWinterp->result = "1";\fR"

.IX Item "Reading \f(CWinterp->result\fR "

.IX Item "\f(CWinterp->result = Tk_PathName(textPtr->tkwin);\fR"

.IX Item "Sequence \f(CWTcl_PrintDouble, Tcl_PrintDouble, ..., Tcl_AppendResult\fR "

.IX Item "\f(CWTcl_SplitList\fR "

.IX Header "Translation back to TCL"

.IX Item "Additional config types:"

.IX Item "Types:"

.IX Item "Functions and macros:"

.IX Subsection "New types of events ????"

.IX Header "Checking for trouble"

.IX Header "Additional API"

.IX Subsection "\f(CWListFactory\fR"

.IX Subsection "DStrings "

.IX Subsection "Accessing \f(CWArg\fRs"

.IX Subsection "Assigning numbers to \f(CWArg\fRs"

.IX Subsection "Creating new \f(CWArg\fRs"

.IX Subsection "Evaluating a list"

.IX Subsection "Getting result as \f(CWArg\fR"

