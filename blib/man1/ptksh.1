.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PTKSH 1 "Tk800.012" "30/Jun/98" "perl/Tk Documentation"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
ptksh \- Perl/Tk script to provide a graphical user interface for testing Perl/Tk
commands and scripts.
.SH "SYNOPSIS"
.PP
.Vb 10
\&  % ptksh  ?scriptfile?
\&  ... version information ...
\&  ptksh> $b=$mw->Button(-text=>'Hi',-command=>sub{print 'Hi'})
\&  ptksh> $b->pack
\&  ptksh> o $b
\&  ... list of options ...
\&  ptksh> help
\&  ... help information ...
\&  ptksh> exit
\&  %
.Ve
.SH "DESCRIPTION"
ptksh is a perl/Tk shell to enter perl commands
interactively.  When one starts ptksh a MainWindow
is automaticly created, along with a ptksh command window.
One can access the main window by typing commands using the
variable \f(CW$mw\fR at the \*(L'ptksh> \*(L' prompt of the command window.
.PP
ptksh supports command line editing and history.  Just type \*(L"<Up>\*(R" at
the command prompt to see a history list.  The last 50 commands entered
are saved, then reloaded into history list the next time you start ptksh. 
.PP
ptksh supports some convenient commands for inspecting Tk widgets.  See below.
.PP
To exit ptksh use: \f(CWexit\fR.
.PP
ptksh is \fB*not*\fR a full symbolic debugger.
To debug perl/Tk programs at a low level use the more powerful
perl debugger.  (Just enter ``O tk'\*(R' on debuggers
command line to start the Tk eventloop.)
.SH "FEATURES"
.Sh "History"
Press <Up> (the Up Arrow) in the perlwish window to obtain a gui-based history list.
Press <Enter> on any history line to enter it into the perlwish window.
Then hit return.  So, for example, repeat last command is <Up><Enter><Enter>.
You can quit the history window with <Escape>.  \s-1NOTE\s0: history is only saved
if exit is \*(L"graceful\*(R" (i.e. by the \*(L"exit\*(R" command from the console or by
quitting all main windows\*(--\s-1NOT\s0 by interrupt).
.Sh "Debugging Support"
ptksh provides some convenience function to make browsing
in perl/Tk widget easier:
.Ip "\fB?\fR, or \fBh\fR" 4
displays a short help summary.
.Ip "\fBd\fR ?\fIargs\fR, ...?" 4
Dumps recursively arguments to stdout. (see the \fIData::Dumper\fR manpage).
You must have <Data::Dumper> installed to support this feature.
.Ip "\fBp\fR ?\fIarg\fR, ...?" 4
appends \*(L"|\en\*(R" to each of it's arguments and prints it.
If value is \fBundef\fR, \*(L'(undef)\*(R' is printed to stdout.
.Ip "\fBo\fR \fI$widget\fR ?\fI\-option\fR ...?" 4
prints the \fIoption\fR\|(s) of \fI$widget\fR one on each line.
If no options are given all options of the widget are
listed.  See the \fITk::options\fR manpage for more details on the
format and contents of the returned list.
.Ip "\fBo\fR \fI$widget\fR \fB/\fR\fIregexp\fR\fB/\fR" 4
Lists options of \fI$widget\fR matching the
regular expression \fIregexp\fR.
.Ip "\fBu\fR ?\fIclass\fR?" 4
If no argument is given it lists the modules loaded
by the commands you executed or since the last time you
called \f(CWu\fR.
.Sp
If argument is the empty string lists all modules that are
loaded by ptksh.
.Sp
If argument is a string, ``text'\*(R' it tries to do a ``use Tk::Text;'\*(R'.
.Sh "Packages"
Ptksh compiles into package Tk::ptksh.  Your code is eval'ed into package
main.  The coolness of this is that your eval code should not interfere with
ptksh itself.
.Sh "Multiline Commands"
ptksh will accept multiline commands.  Simply put a \*(L"\e\*(R" character immediately
before the newline, and ptksh will continue your command onto the next line.
.Sh "Source File Support"
If you have a perl/Tk script that you want to do debugging on, try running the
command
.PP
.Vb 5
\&  ptksh> do 'myscript';
\&   
\&   -- or  (at shell command prompt) --
\&  
\&  % ptksh myscript
.Ve
Then use the perl/Tk commands to try out different operations on your script.
.SH "ENVIRONMENT"
Looks for your .ptksh_history in the directory specified by
the \f(CW$HOME\fR environment variable ($HOMEPATH on Win32 systems).
.SH "FILES"
.Ip "\fI.ptksh_init\fR" 4
If found in current directory it is read in an evaluated
after the mainwindow \fI$mw\fR is created. \fI.ptksh_init\fR
can contain any valid perl code.
.Ip "\fI~/.ptksh_history\fR" 4
Contains the last 50 lines entered in ptksh \fIsession\fR\|(s).
.SH "PITFALLS"
It is best not to use \*(L"my\*(R" in the commands you type into ptksh.
For example \*(L"my \f(CW$v\fR\*(R" will make \f(CW$v\fR local just to the command or commands
entered until <Return> is pressed.
For a related reason, there are no file-scopy \*(L"my\*(R" variables in the
ptksh code itself (else the user might trounce on them by accident).
.SH "BUGS"
\fBTk::MainLoop\fR function interactively entered or sourced in a
init or script file will block ptksh.
.SH "SEE ALSO"
Tk
perldebug
.SH "VERSION"
VERSION 2.01 6/18/98
.SH "AUTHORS"
Mike Beller <beller@penvision.com>,
Achim Bohnet <ach@mpe.mpg.de>
.PP
Copyright (c) 1996 \- 1998 Achim Bohnet and Mike Beller. All rights reserved.
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

.rn }` ''
.IX Title "PTKSH 1"
.IX Name "ptksh - Perl/Tk script to provide a graphical user interface for testing Perl/Tk
commands and scripts."

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "FEATURES"

.IX Subsection "History"

.IX Subsection "Debugging Support"

.IX Item "\fB?\fR, or \fBh\fR"

.IX Item "\fBd\fR ?\fIargs\fR, ...?"

.IX Item "\fBp\fR ?\fIarg\fR, ...?"

.IX Item "\fBo\fR \fI$widget\fR ?\fI\-option\fR ...?"

.IX Item "\fBo\fR \fI$widget\fR \fB/\fR\fIregexp\fR\fB/\fR"

.IX Item "\fBu\fR ?\fIclass\fR?"

.IX Subsection "Packages"

.IX Subsection "Multiline Commands"

.IX Subsection "Source File Support"

.IX Header "ENVIRONMENT"

.IX Header "FILES"

.IX Item "\fI.ptksh_init\fR"

.IX Item "\fI~/.ptksh_history\fR"

.IX Header "PITFALLS"

.IX Header "BUGS"

.IX Header "SEE ALSO"

.IX Header "VERSION"

.IX Header "AUTHORS"

